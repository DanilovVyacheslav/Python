Мой вклад величие России - это 13 всероссийский конкурс, срок 28 октября
10 всероссийский конкурс креативных проектов и идей по развитие социальной структуры "НЕОТЕРА"
срок до 21 октября.
                                                                            Модульная математика петон.
** - возведение в степень 
% - остаток от деления
// - целочисленное деление
Оператор возведения в степень а**n
Оператор возведение в степень, может возводить не только в положительную степень, но и в отрицательную.
Аналогично, может быть отрицательном числом.
Оператор возведение в степень, является правоассоциативным.
Значение выражение является справо налево.
Таким образом, выражение x**z**y вычисляется как x**(z**z)
                                                             Целое численное деление.
Для положительных чисел, оператор целочисленного деления ведет себя как обычное деление, за исключением того, что он отбрасывает десятичную часть результата.
Определение отрицательных чисел необходимо помнить, что результат целочисленного деления не привосходит частным.  Другими словами округление берется в сторону целого числа.
                                                             Деление с остатком.
Оператор с делением остатком, возвращает остаток от деления двух целых чисел.                                                             
Оператор в нахождении остатка, очень полезен для решения задач.
Операторы // и % имеют такой же приоритет, как и операторы умножение и обычного деления.

#b1=int(input())
#q=int(intput(
#n=int(input())
#bn=b1*q**(n-1)
#print(bn)

#print("Введите см")
#cm=int(input())
#m=cm//100
#print(m)

#a=int(input())
#b=int(input())
#c= a//b
#d= a % b 
#print(c)
#print(d)

#print("Жителлей")
#=int(input())
#print("Щелчек")
#print("Очистка")
#c=a//2+a%2
#print("Остались живы:", с)

#print("Какой номер?")
#a=int(input())
#b=((a+3)//4)
#print("Это в купе",b)

26.09.2022
Условный оператор IF-ELSE
Программы должны уметь выполнять различные действия в зависимости от введеных данных. Для принятия решения программа проверяет истенно или ложно определённое условие.
В питон существует несколько способов проверки и в каждом случае возможно два исхода:
1.Истина(true)
2.Ложь(False)

Проверка условий и принятие решений по результатам этой проверки, называется ВЕТВЛЕНИЕ. Программа таким способом выбирает по какой из возможных ветвей ей двигаться дальше.
Python проверка условий осуществляется при помощи ключевого слово IF. : С инструкцией IF  сообщает интерпретатору Python, что дальше находится блок команд. В блок команд входят все строки со отступом под строкой, с инструкцией IF вплоть до след. строки без отступа. Если условие истены выполняется весь расположенный ниже блок.
 Блоком кода называют объедененные друг с другом строки, они всегда связанны с определенной части программы и в питон формируются при  помощи отступа.
 ![image](https://user-images.githubusercontent.com/112687983/192217859-3576ac6f-9275-4455-a68f-0d7570f6acac.png)
 ![image](https://user-images.githubusercontent.com/112687983/192219470-e098ab82-e4ff-44a1-9b03-14eb55cc1761.png)
 Если условие ложно, мы используем ключевое слово else
Отступ-это небольшое смещение строки кода вправо. По соглашение PEP8 для отступа ввода кода используется 4 пробела(Табуляция). 
Оперторы сравнения: 
В проверке условия всегда ставится ==. Один знак = (оператор присваивания). Присваивает переменным значением. Для проверки двух элементов на равенства в питон использует удвоенный знак равно (==).
В Python существует 6 основных операторов сравнения.
![image](https://user-images.githubusercontent.com/112687983/192221089-9962f6ba-b7eb-43c4-b06f-d3b2f778fef5.png)
Цепочка сравнений.
Операторы сравнения в Python можно объединять в цепочки (в отличии от большинства других языков программирования, где для этого нужно использовать логические связки), например, a == b == c или 1 <= x <= 10. Следующий код проверяет, находится ли значение переменной age в диапазоне от 3 до 6:
age = int(input())
if 3 <= age <= 6:
    print('Вы ребёнок')
    Код, проверяющий равенство трех переменных, может выглядеть так:
if a == b == c:
    print('числа равны')
else:
    print('числа не равны')
                                                            Транзитивность.
Операция равенства является транзитивной. Это означает, что если a == b и b == c, то из этого следует, что a == c. Именно поэтому предыдущий код, проверяющий равенство трёх переменных, работает как полагается. 
Из курса математики вам могут быть знакомы другие примеры транзитивных операций:
* Отношение порядка: если a > b и b > , то a > c.
* Параллельность прямых: если a > параллельно b и b параллельно c, то a параллельно c.
* Делимость:если a делится на b и b делится на c, то a делится на с.
Операция неравенства (!=), в отличие от операции равенства (==), является нетранзитивной. То есть из того, что a != b и b != c,вовсе не следует, что a != c. Действительно, если вас зовут не так, как соседа слева и не так, как соседа справа, то нет гарантии, что у обоих соседей не окажутся одинаковые имена.
Таким образом, следующий код вовсе не проверяет тот факт, что все три переменные различны:
if a != b != c:
    print('числа не равны')
else:
print('числа равны').
https://colab.research.google.com/drive/1BhGkLiiW-2k2VV7hDQdbIp5gSNxXAtig?usp=sharing

Логические операторы.
В Python есть три логических оператора, которые позволяют создавать сложные условия:
and — логическое умножение;
or — логическое сложение;
not — логическое отрицание.
Оператор and может объединять произвольное количество условий:
age = int(input('Сколько вам лет?: '))
grade = int(input('В каком классе вы учитесь?: '))
city = input('В каком городе вы живете?: ')
if age >= 12 and grade >= 7 and city == 'Москва':
    print('Доступ разрешен.')
else:
    print('Доступ запрещен.')
    ![image](https://user-images.githubusercontent.com/112687983/193531192-a4215a93-803b-4f68-b05e-bd9952672b3c.png)
Оператор or
Оператор or также применяется для объединения условий. Однако, в отличие от and, для выполнения блока кода достаточно выполнения хотя бы одного из условий.
city = input('В каком городе вы живете?: ')
if city == 'Москва' or city == 'Санкт-Петербург' or city == 'Екатеринбург':
print('Доступ разрешен.')
else:
print('Доступ запрещен.')
![image](https://user-images.githubusercontent.com/112687983/193531771-c7defc25-bd30-4182-aad1-fcbe01ae8dc5.png)
Логическое выражение X and Y истинно, если оба значения X и Y истинны.
Логическое выражение X or Y истинно, если хотя бы одно из значений X и Y истинно.
Мы можем использовать оба логических оператора одновременно:
age = int(input('Сколько вам лет?: '))
grade = int(input('В каком классе вы учитесь?: '))
city = input('В каком городе вы живете?: ')
if age >= 12 and grade >= 7 and (city == 'Москва' or city == 'Санкт-Петербург'):
    print('Доступ разрешен.')
else:
    print('Доступ запрещен.')
    Оператор not
Оператор not позволяет инвертировать (т.е. заменить на противоположный) результат логического выражения. Например, следующий код:
age = int(input('Сколько вам лет?: '))
if not (age < 12):
    print('Доступ разрешен.')
else:
    print('Доступ запрещен.')

полностью эквивалентен коду:

age = int(input('Сколько вам лет?: '))
if age >= 12:
    print('Доступ разрешен.')
else:
    print('Доступ запрещен.').
    Приоритеты логических операторов.
в первую очередь выполняется логическое отрицание not;
далее выполняется логическое умножение and;
далее выполняется логическое сложение or.
Для явного указания порядка выполнения условных операторов используют скобки.
Оба оператора, and и or, вычисляются по укороченной схеме.
Вот как это работает с оператором and. Если условие слева от оператора and является ложным, то условие справа от него не проверяется, так как результат выражения будет гарантированно ложным и проверка оставшегося условия — пустая трата процессорного времени.
Аналогично работает оператор or. Если условие слева от оператора or истинное, то условие справа от него не проверяется. Действительно, результат будет гарантированно истинным и проверка оставшегося условия станет пустой тратой процессорного времени.

18.10.2022
Тема: Преобразование строки в целое число.
Для преобразование строки в целое число, мы используем команду int():
num = int(input()) # преобразование считанной строки в целое число.
Для преобразование строки в целое число не обязательно использовать команду input().
Следующий код преобразует строку 12345 в целое число:
n = int(`12345`).
Язык python представляет четыре арифмитических опратора для работы с целыми числами (+,-,*,/), а также три дополнительных (% для остатка, // для целочисленного деления и ** для возведения в степень).
Следующая программа демонстрирует все целочисленные операторы:
a - 13
b - 7.
На равне с целыми числами в Python есть возможность  работы с дробными (вещественными) числами.
В отличие от математики, где разделителем является запятая, в информатике.
Модули.
В Петоне, есть множество разнообразных функций, кторые уже реализованны и готовы к использованию. Такие функции упакованны в модули и называются библиотека функций.
Модуль math.
Модуль math - один из наиважнейших в Python.
Если необходимо подключить модуль math, пользуеются командой input.
![image](https://user-images.githubusercontent.com/112687983/196395617-65e6d575-aed8-4913-925d-e3541ef3c5bf.png)
![image](https://user-images.githubusercontent.com/112687983/196396070-668639ca-12b3-4bde-8fa4-b73a3dbeac19.png)
![image](https://user-images.githubusercontent.com/112687983/196396629-be84fa81-1317-4c21-800c-a697284ced7b.png).

19.10.2022
Тема: Цикл for.
Одно тиз преимуществ компьютеров перед людьми, заключается в том, что компьютеры способны повторять, одни и те же действия многократно.
В питонг существует две основных разновидности циклов. Циклы повторяющиеся определенные кол-ва раз ( for, счетные цикла, couting loops).
Wbrk FOR ЗАМЕЧАТЕЛЬНО РАБОТАЕТ, ЕСЛИ МЫ ЗАРАНЕЕ знаем 
Структура циклов for в питоне, выглядит так: for, название переменной цикла, in range, кол-во повторений):
Блок кода
В программе может быть сколько угодно циклов. Например, если мы хотим , чтобы 5 раз был напечатан символ С, а затем 5 раз символ D.
           Переменная цикла.
Давайте еще раз взглянем на базовую структуру цикла for:
for название_переменной_цикла in range(количество повторений):
блок кода
Не совсем понятно, для чего нужна и как работает переменная цикла.
Как видно из кода , в питон в цикл for, начинается с 0.
По скольку переменная цикла (i) увеличивается на 1 каждый раз, то её можно использовать для отслеживания номера итерации, на который мы находимся в циклическом процессе.
              Имена переменных цикла.
Имена переменных должны носить осмысленный характер и оптсывать их назначение.
Ранее говорилось, что имена переменных должны носить осмысленный характер и описывать их назначение. Однако для переменных цикла иногда делается исключения. В программировании для переменных цикла обычно используют буквы i, j, k.
Бываюит ситуации, когда переменные цикла не используется в теле цикла. В этом случае, вместо того, чтобы давать им имя указывают символ, нижнего подчеркивания.
    Функция range с 1 параметром.
Значение, которое мы указываем в скобках у функции range означает кол-во итерации цикла. Иными словами функция range (n) гинерирует последоват. чисел от 0 до n - 1, а цикл for последовательно перебирает эту последовательность.
  Перезагрузка range с двумя параметрам.
Если мы хротим начинать последовательность не с 0, а с какого то, другого числа, то мы можем использовать перезагрузку функции range принимающую 2 параметра например вызов функции range 1,5 сгенерирует последовательность чисел 1,2,3,4,5. Таким образом, range (n), создает последовательность чисел от 0 до n-1. Range (m) . Напишите программу, которая выводит те числа, из промежутка [100,99] , которые оканчиваются на 7 используя функции range с двумя параметрами
if i% 10 = 7: # используя
 
      Цикл White.
Цикл for замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам потребуется сделать. Но иногда нужно, чтобы цикл выполнялся до наступления некоторого события, и количество итераций в этом случае заранее оценить просто невозможно. И здесь на помощь приходит цикл while.
Структура цикла while в Python выглядит так:

while условие:
    блок кода
Двоеточие (:) в конце строки с инструкцией while сообщает Python, что дальше находится блок команд. В блок входят все строки, расположенные с отступом от строки с инструкцией while, вплоть до следующей строки без отступа.
Блок команд, который выполняется в цикле while, называется телом цикла.

Рассмотрим код, использующий цикл while, который распечатает 10 раз слово Привет:

i = 0
while i < 10:
    print('Привет')
    i += 1
    Такой код можно легко заменить циклом for, поскольку мы заранее знаем сколько раз нужно выполнить тело цикла. Однако так бывает не всегда.
Напишем программу, которая считывает числа и выводит их квадраты, пока не будет введено -1. При такой постановке задачи мы не можем воспользоваться циклом for, так как не знаем сколько чисел будет предшествовать числу -1.
num = int(input())
while num != -1:
    print('Квадрат вашего числа равен:', num * num)
    num = int(input())

В качестве начального значения переменной num, мы используем первое из чисел. Далее пока выполняется условие цикла, а именно, пока введенное число не равно -1, мы исполняем тело цикла. В тело цикла входит две команды:
напечатать квадрат введенного числа;
считать следующее число. 

Важным являются два момента:
1. правильная инициализация переменной num;
2. изменение переменной num внутри цикла while.
Важно: если не изменять переменную num внутри цикла, то можно получить так называемый бесконечный цикл, который будет выполняться бесконечно много раз.
Цикл while очень похож на условный оператор if. Разница заключается в том, что в случае с условным оператором соответствующий блок кода будет выполняться только один раз, тогда как с циклом while блок кода будет выполнен многократно.
    Цикл for VS цикл while
Мы всегда можем заменить цикл for с помощью цикла while. Следующие две программы выводят числа от 0 до 100:
# используем for
for i in range(101):
    print(i)

# используем while
i = 0
while i < 101:
    print(i)
    i += 1
В первом цикле переменная i последовательно принимает значения от 0 до 100. Для цикла while, нам пришлось завести самостоятельно переменную i и придать ей начальное значение. Тело цикла while содержит аналогичную инструкцию вывода print(i), однако помимо этого мы самостоятельно увеличиваем значение переменной i на 1, что делается автоматически в случае с циклом for.

Напишем программу, выводящую все числа, кратные 3, используя цикл for и while:
# используем for
for i in range(0, 100, 3):
    print(i)

# используем while
i = 0
while i < 100:
    print(i)
    i += 3
Не всегда, однако удается заменить цикл while с помощью цикла for. Если заранее не известно количество итераций, то необходимо использовать цикл while и только его.

  Считывание данных до стоп значения.
Часто при решении задач на цикл while, мы считываем данные, до тех пор пока пользователь не введет некоторое значение, которое называют стоп значением. Напишем программу, которая считывает числа и находит их сумму, до тех пор пока пользователь не введет слово stop:
text = input()
total = 0
while text != 'stop':
    num = int(text)
    total += num
    text = input()
print('Сумма чисел равна', total)
Такой код будет часто использоваться при решении задач.
   Бесконечный цикл.
Всегда, кроме редких случаев, цикл while должен содержать возможность завершиться. То есть в цикле что-то должно сделать проверяемое условие ложным. Если цикл не имеет возможности завершиться, то он называется бесконечным циклом. Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Бесконечные циклы обычно появляются, когда программист забывает написать программный код внутри цикла, который делает проверяемое условие ложным. В большинстве случаев следует избегать применения бесконечных циклов.
Пример бесконечного цикла:

i = 0
total = 0
while i < 10:
total += i

Так как в теле цикла не происходит изменения переменной i, то условие i < 10 остается истинным и цикл выполняется бесконечно много раз.
Бесконечные циклы можно использовать в связке с оператором прерывания break. 

Примечания:
Примечание 1. Цикл while получил свое название из-за характера своей работы: он выполняет некую задачу до тех пор, пока условие является истинным. Слово while на английском означает как раз "пока".
Примечание 2. Цикл while называют циклом с предусловием, поскольку выполнению тела цикла предшествует проверка условия (сначала проверяется условие, а уже затем выполняется тело цикла).
Примечание 3. Однократное выполнение тела цикла называется итерацией цикла.
Примечание 4. Цикл while может не выполниться ни одного раза. Например, следующий код:
i = -1
while i > 0:
    print('Hello world!')
не выведет текст, поскольку условие i > 0 ложно с самого начала.
Примечание 5. Графическое представление цикла while имеет вид: 
while условие:
      блок кода
Примечание 6. Условие в цикле while, как и в условном операторе if, может содержать логические операции or, and, not. 

31.10.2022.
Есть три типа команд:break, continue, else
Оператор прерывания цикла break.
Иногда бывает нужно прервать выполнение цикла преждевременно. Оператор break прерывает ближайший цикл for или while.
Усовершенствуем программу, проверяющую число на простоту с помощью оператора break:
Напишем программу, определяющую, что число является простым:

num = int(input())
flag = True
for i in range(2, num):
    if num % i == 0:        #  если исходное число делится на какое-либо отличное от 1 и самого себя
        flag = False
        break               # останавливаем цикл если встретили делитель числа        
if flag == True:
    print('Число простое')
else:
    print('Число составное')
Как только мы встречаем делитель отличный от 1 и num, мы меняем значение сигнальной метки и прерываем цикл, поскольку дальнейшее его выполнение лишено смысла: число гарантированно не является простым.
Оператор прерывания цикла break позволяет ускорять программы, так как мы избавляемся от лишних итераций.
Напишем программу, использующую цикл for, которая считывает 10 чисел и суммирует их до тех пор, пока не обнаружит отрицательное число. В этом случае выполнение цикла прерывается командой break:
result = 0
for i in range(10):
    num = int(input())
    if num < 0:
        break
    result += num
print(result)

Оператор прерывания цикла break удобен в связке с сигнальными метками: когда после проверки некоторого условия нам нет смысла продолжать выполнение цикла. Сигнальная метка (флажок) может использоваться, когда надо чтобы одна часть программы узнала, о происходящем в другой части программы.

Как только мы встретили цифру 7, мы меняем значение сигнальной метки и прерываем цикл с помощью оператора break. Мы можем и не прерывать цикл преждевременно, а дождаться его естественного завершения (условие num != 0, то есть все цифры числа обработаны), однако в таком случае мы будем совершать лишнюю работу, и в случае если число очень большое, то программа будет работать медленнее.
Бесконечные циклы
В предыдущих уроках мы говорили о цикле, который не имеет возможности завершиться и назвали его бесконечным циклом. Самый простой способ создать бесконечный цикл в Python – записать следующий код:
while True:
    print('Python awesome!')
Результатом выполнения такого кода будет бесконечное количество строчек текста:
Python awesome!
Python awesome!
.
.
.
Python awesome!
Python awesome!
Python awesome!
Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Изучив оператор break, мы получили механизм прерывания бесконечных циклов.

Оператор continue
Другая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор continue позволяет перейти к следующей итерации цикла for или while до завершения всех команд в теле цикла.
Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78.
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию
    print(i)
Примечания
Примечание 1. Оператор break прерывает выполнение ближайшего цикла, а не программы, то есть далее будет выполнена команда, следующая сразу за циклом.
![image](https://user-images.githubusercontent.com/112687983/198994378-79c65e09-5910-46df-9e9d-321c681ef8c4.png)

Ревью кода.
Ревью кода – проверка исходного кода программы с целью обнаружения и исправления ошибок и неточностей, которые остались незамеченными при начальной разработке. 
В процессе ревью кода могут быть исправлены:
фактические ошибки;
производительность кода;
читабельность кода и ошибки форматирования кода.
Целью ревью кода является улучшение качества программного кода и совершенствование навыков программиста.
Как правило ревью кода выполняет программист с большим опытом.

Фактические ошибки.
К фактическим ошибкам в коде относятся ошибки из-за которых код может работать неверно. По сути, это ошибки относящиеся к алгоритму, который используется в программе для решения задачи.

Среди частых фактических ошибок встречаются:

отсутствие начальной инициализации переменной;
неправильная начальная инициализация переменной;
отсутствие отступа (в Python блоки кода выделяются отступами);
неправильные числовые граничные значения, например при использовании функции range();
неправильные граничные сравнения (путаница с >, >= или <, <=);
путаница логических операций or и and и т.д.

02.11.2022.
Вложенные циклы
Вложенный цикл расположен в еще одном цикле. Часы служат хорошим примером работы вложенного цикла. Секундная, минутная и часовая стрелки вращаются вокруг циферблата.Часовая стрелка смещается всего на 1 шаг для каждых 60 шагов минутной стрелки. И секундная стрелка должна сделать 60 шагов для 1 шага минутной стрелки. Это означает, что для каждого полного оборота часовой стрелки (12 шагов), минутная стрелка делает 720 шагов.
Пример имитационной модели часов подводит нас к нескольким моментам, имеющим отношение к вложенным циклам:
вложенный цикл выполняет все свои итерации для каждой отдельной итерации внешнего цикла;
вложенные циклы завершают свои итерации быстрее, чем внешние циклы;
для того, чтобы получить общее количество итераций вложенного цикла, надо перемножить количество итераций всех циклов.
    Мы можем вкладывать друг в друга циклы как for, так и while.
Оператор break выполняет прерывание ближайшего цикла в котором он расположен. Аналогично, оператор continue осуществляет переход на следующую итерацию ближайшего цикла.
Рассмотрим программный код:
for i in range(3):
    for j in range(3):
        print(i, j)
Результатом его выполнения будут 9 строк:
0 0
0 1
0 2
1 0
1 1
1 2
2 0
2 1
2 2

03.11.2022
Использование вложенных циклов при решении уравнений
Вложенные циклы можно использовать для решения уравнений с несколькими переменными. Зная, что решения (корни) уравнения являются натуральными (целыми) числами, несложно написать программу, содержащую вложенный цикл и перебирающую все возможные значения переменных.

Строки.
Строки в Python используются когда надо работать с текстовыми данными.
Создание строки. Для создания строк, мы используем парные кавычки '' или "":

s1 = 'Python'
s2 = "Pascal"

Считывание строки. Для считывания текстовых данных в строковую переменную, мы используем функцию input():

s = input()  # считали текст
num = int(input())  # считали текст и преобразовали его в целое число

Пустая строка. Для создания пустой строки, мы пишем s = '' или s = "". Пустая строка – это аналог числа 0.
Длина строки. Для определения длины строки (количества символов), мы используем встроенную функцию len():

s = 'Hello'
n = len(s)  # значение переменной равно 5
print(n)

Конкатенация и умножение на число.
Операторы + и * можно использовать для строк. Оператор + сцепляет две и более строк. Это называется конкатенацией строк. Оператор * повторяет строку указанное количество раз. 
![image](https://user-images.githubusercontent.com/112687983/199676180-0c8e7435-5184-44e6-9e6f-18ed308e0e0c.png)
Оператор принадлежности in. С помощью оператора in, мы можем проверять, находится ли одна строка в составе другой. То есть, является ли одна строка подстрокой другой:
s = 'All you need is love'
if 'love' in s:
    print('❤️')
else:
    print('💔')
Так как строка s содержит подстроку 'love', то будет выведен смайлик ❤️.
В Python можно использовать смайлики emoji👍
![image](https://user-images.githubusercontent.com/112687983/199676697-e783ba54-c6e4-4bc6-87ea-c7c142aa1cbb.png)

Таким образом, получаем
![image](https://user-images.githubusercontent.com/112687983/199677021-b6bf2084-3cdb-4149-b593-1a217392f596.png)
Частая ошибка у начинающих программистов — обращение по несуществующему индексу в строке.
Например, если s = 'Python', и мы попытаемся обратится к s[17], то мы получим ошибку:
IndexError: string index out of range
Ошибка возникает, поскольку строка содержит всего 6 символов.
Обратите внимание: если длина строки s равна len(s), то при положительной нумерации слева направо, последний элемент имеет индекс равный len(s) - 1, а при отрицательной индексации справа налево, первый элемент имеет индекс равный -len(s).
Итерирование строк
Очень часто нужно просканировать всю строку целиком, обрабатывая каждый ее символ. Для этого удобно использовать цикл for. Напишем программу, которая выводит каждый символ строки на отдельной строке:
s = 'abcdef'
for i in range(len(s)):
print(s[i])
Результатом выполнения такой программы будут строки:
a
b
c
d
e
f
Мы передаем в функцию range() длину строки len(s). В нашем случае длина строки s, равна 6. Таким образом, вызов функции range(len(s)) имеет вид range(6) и переменная цикла i последовательно перебирает все значения от 0 до 5. Это означает, что выражение s[i] последовательно вернет все символы строки s. Такой способ итерации строки удобен, когда нам нужен не только сам элемент s[i], но и его индекс i.

07.11.2022
Делаем срезы 1
На вход программе подается одна строка. Напишите программу, которая выводит:
общее количество символов в строке;
исходную строку повторенную 3 раза;
первый символ строки;
первые три символа строки;
последние три символа строки;
строку в обратном порядке;
строку с удаленным первым и последним символом.
Формат входных данных
На вход программе подается одна строка, длина которой больше 3 символов.
Формат выходных данных
Программа должна вывести данные в соответствии с условием. Каждое значение выводится на отдельной строке.

s = input()

print(len(s))   # общее количество символов в строке;
print(s * 3)    # исходную строку повторенную 3 раза;
print(s[0])     # первый символ строки;
print(s[:3])    # первые три символа строки;
print(s[-3:])   # последние три символа строки;
print(s[::-1])  # строку в обратном порядке;
print(s[1:-1])  # строку с удаленным первым и последний символом.

Методы и функции
Мы уже знакомы с некоторыми встроенными функциями: min(),max(),len(),int(),float() и т.д. Метод — специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения.

Таким образом: метод — функция, применяемая к объекту. В данном случае к строке. Метод вызывается в виде имя_объекта.имя_метода(параметры).
Например, s.find('e') — это применение к строке s метода find с одним параметром 'e'.

Методы строкового типа данных можно разделить на три группы:

Конвертация регистра;
Поиск и замена;
Классификация символов.

Конвертация регистра
Методы в этой группе выполняют преобразование регистра для строк.

Метод capitalize()

Метод capitalize() возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.
Результатом выполнения следующего кода:
s = 'foO BaR BAZ quX'
print(s.capitalize())
будет:
Foo bar baz qux

Символы, не являющиеся буквами алфавита, остаются неизменными. Результатом выполнения следующего кода:
s = 'foo123#BAR#.'
print(s.capitalize())
будет:
Foo123#bar#.

етод swapcase()
Метод swapcase() возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.
 Результатом выполнения следующего кода:
s = 'FOO Bar 123 baz qUX'
print(s.swapcase())
будет:
foo bAR 123 BAZ Qux
Метод title()
Метод title() возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр.
Результатом выполнения следующего кода:
s = 'the sun also rises'
print(s.title())
будет:
The Sun Also Rises
Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы. Результатом выполнения следующего кода:
s = "what's happened to ted's IBM stock?"
print(s.title())
будет:
What'S Happened To Ted'S Ibm Stock?
 Метод lower()
Метод lower() возвращает копию строки s, в которой все символы имеют нижний регистр.
Результатом выполнения следующего кода:
s = 'FOO Bar 123 baz qUX'
print(s.lower())
будет:
foo bar 123 baz qux
Метод upper()
Метод upper() возвращает копию строки s, в которой все символы имеют верхний регистр.
Результатом выполнения следующего кода:
s = 'FOO Bar 123 baz qUX'
print(s.upper())
будет:
FOO BAR 123 BAZ QUX

09.11.2022
Методы и функции Мы уже знакомы с некоторыми встроенными функциями: min(),max(),len(),int(),float() и т.д. Метод — специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения.

Таким образом: метод — функция, применяемая к объекту. В данном случае к строке. Метод вызывается в виде имя_объекта.имя_метода(параметры). Например, s.find('e') — это применение к строке s метода find с одним параметром 'e'.

Методы строкового типа данных можно разделить на три группы:

Конвертация регистра; Поиск и замена; Классификация символов.

Конвертация регистра Методы в этой группе выполняют преобразование регистра для строк.

Метод capitalize()

Метод capitalize() возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр. Результатом выполнения следующего кода: s = 'foO BaR BAZ quX' print(s.capitalize()) будет: Foo bar baz qux

Символы, не являющиеся буквами алфавита, остаются неизменными. Результатом выполнения следующего кода: s = 'foo123#BAR#.' print(s.capitalize()) будет: Foo123#bar#. Метод swapcase() Метод swapcase() возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот. Результатом выполнения следующего кода: s = 'FOO Bar 123 baz qUX' print(s.swapcase()) будет: foo bAR 123 BAZ Qux Метод title() Метод title() возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр. Результатом выполнения следующего кода: s = 'the sun also rises' print(s.title()) будет: The Sun Also Rises Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы. Результатом выполнения следующего кода: s = "what's happened to ted's IBM stock?" print(s.title()) будет: What'S Happened To Ted'S Ibm Stock?

Метод lower()

Метод lower() возвращает копию строки s, в которой все символы имеют нижний регистр. Результатом выполнения следующего кода: s = 'FOO Bar 123 baz qUX' print(s.lower()) будет: foo bar 123 baz qux

Метод upper()

Метод upper() возвращает копию строки s, в которой все символы имеют верхний регистр. Результатом выполнения следующего кода: s = 'FOO Bar 123 baz qUX' print(s.upper()) будет: FOO BAR 123 BAZ QUX

Поиск и замена Методы поиска и замены строк внутри других строк. Каждый метод в этой группе поддерживает необязательные аргументы 'start' и 'end'. Как и в строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции символа 'start' и продолжающейся вплоть до позиции символа 'end', но не включающей ее. Если параметр 'start' указан, а параметр 'end' нет, то метод применяется к части исходной строки от 'start' до конца строки. Если параметры не заданы, то подразумевается, что 'start' = 0 , 'end' = len(s).

Метод count()

Метод count('sub', 'start', 'end') считает количество непересекающихся вхождений подстроки 'sub' в исходную строку s. Результатом выполнения следующего кода: s = 'foo goo moo' print(s.count('oo')) print(s.count('oo', 0, 8)) # подсчет с 0 по 7 символ будет: 3 2

Метод startswith()

Метод startswith('suffix', 'start', 'end') определяет начинается ли исходная строка s подстрокой 'suffix'. Если исходная строка начинается с подстроки 'suffix',метод возвращает значение True, а если нет, то False. Результатом выполнения следующего кода: s = 'foobar' print(s.startswith('foo')) print(s.startswith('baz')) будет: True False

Метод endswith()

Метод endswith('suffix', 'start', 'end') определяет оканчивается ли исходная строка s подстрокой 'suffix'. Метод возвращает значение True если исходная строка оканчивается на подстроку 'suffix' и False в противном случае. Результатом выполнения следующего кода: s = 'foobar' print(s.endswith('bar')) print(s.endswith('baz')) будет: True False

Методы find(), rfind()

Метод find('sub', 'start', 'end') находит индекс первого вхождения подстроки 'sub' в исходной строке s. Если строка s не содержит подстроки 'sub', то метод возвращает значение -1. Мы можем использовать данный метод наравне с оператором in для проверки: содержит ли заданная строка некоторую подстроку или нет. Результатом выполнения следующего кода: s = 'foo bar foo baz foo qux' print(s.find('foo')) print(s.find('bar')) print(s.find('qu')) print(s.find('python')) будет: 0 4 20 -1 Метод rfind('sub', 'start', 'end') идентичен методу find('sub', 'start', 'end'), за тем исключением, что он ищет первое вхождение подстроки 'sub' начиная с конца строки s.

Методы index(), rindex()

Метод index('sub', 'start', 'end') идентичен методу find('sub', 'start', 'end'), за тем исключением, что он вызывает ошибку ValueError: substring not found во время выполнения программы, если подстрока 'sub' не найдена. Метод rindex('sub', 'start', 'end') идентичен методу index('sub', 'start', 'end'), за тем исключением, что он ищет первое вхождение подстроки 'sub' начиная с конца строки s. Методы find() и rfind() являются более безопасными чем index() и rindex(), так как не приводят к возникновению ошибки во время выполнения программы.

Метод strip() Метод strip() возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки. Результатом выполнения следующего кода: s = ' foo bar foo baz foo qux ' print(s.strip()) будет: foo bar foo baz foo qux

Метод lstrip()

Метод lstrip() возвращает копию строки s у которой удалены все пробелы стоящие в начале строки. Результатом выполнения следующего кода: s = ' foo bar foo baz foo qux ' print(s.lstrip()) будет: foo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵

Метод rstrip()

Метод rstrip() возвращает копию строки s у которой удалены все пробелы стоящие в конце строки. Результатом выполнения следующего кода: s = ' foo bar foo baz foo qux ' print(s.rstrip()) будет: ⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux

Методы strip(), lstrip(), rstrip() могут принимать на вход опциональный аргумент'chars'. Необязательный аргумент 'chars'– это строка, которая определяет набор символов для удаления.

Метод replace()

Метод replace('old', 'new') возвращает копию s со всеми вхождениями подстроки 'old', замененными на 'new'. Результатом выполнения следующего кода: s = 'foo bar foo baz foo qux' print(s.replace('foo', 'grault')) будет: grault bar grault baz grault qux

Метод replace() может принимать опциональный третий аргумент 'count', который определяет количество замен. Результатом выполнения следующего кода: s = 'foo bar foo baz foo qux' print(s.replace('foo', 'grault', 2)) будет: grault bar grault baz foo qux

10.11.2022.
Представление строк в памяти компьютера, ASCII и Unicode.
Любой набор данных в оперативной памяти (конспект информации представленной по данной ссылке) компьютера должен храниться в виде двоичного числа. Это относится и к строкам, которые состоят из символов (буквы, знаки препинания и т.д.). Когда символ сохраняется в памяти, он сначала преобразуется в цифровой код. И затем этот цифровой код сохраняется в памяти как двоичное число.
За прошедшие годы для представления символов в памяти компьютера были разработаны различные схемы кодирования. Исторически самой важной из этих схем кодирования является схема кодирования ASCII (American Standard Code for Information Interchange – американский стандартный код обмена информацией).
Таблица символов ASCII
ASCII представляет собой набор из 128 цифровых кодов, которые обозначают английские буквы, различные знаки препинания и другие символы. Например, код ASCII для прописной английской буквы «А» (латинской) равняется 65. Когда на компьютерной клавиатуре вы набираете букву «А» в верхнем регистре, в памяти сохраняется число 65 (как двоичное число, разумеется).
![image](https://user-images.githubusercontent.com/112687983/201028315-ca564021-a48c-4e32-bbd5-2a762980a774.png)

В начале 1990-х годов был разработан набор символов Юникода (Unicode). Это широкая схема кодирования, совместимая с ASCII, которая может также представлять символы многих языков мира. Сегодня Юникод быстро становится стандартным набором символов, используемым в компьютерной индустрии.
Таблица символов Unicode
Таблица символов Юникод представляет собой набор цифровых символов, которые включают в себя знаки почти всех письменных языков мира. Стандарт предложен в 1991 году некоммерческой организацией «Консорциум Юникода». Применение этого стандарта позволяет закодировать очень большое число символов из разных систем письменности: в документах, закодированных по стандарту Юникод, могут соседствовать китайские иероглифы, математические символы, буквы греческого алфавита, латиницы и кириллицы, символы музыкальной нотной нотации.
Стандарт состоит из двух основных частей: универсального набора символов и семейства кодировок (Unicode transformation format, UTF). Универсальный набор символов перечисляет допустимые по стандарту Юникод символы и присваивает каждому символу код в виде неотрицательного целого числа. Семейство кодировок определяет способы преобразования кодов символов для хранения на компьютере и передачи.
В Юникод все время добавляются новые символы, а сам размер этой таблицы не ограничен и будет только расти, поэтому сейчас при хранении в памяти одного юникод-символа может потребоваться от 1 до 8 байт. Отсутствие ограничений привело к тому, что стали появляться символы на все случаи жизни.
В Python строки хранятся в виде последовательности юникод символов.
Примечания
Примечание 1. Официальный сайт таблицы символов Unicode.
Примечание 2. Юникод — это не кодировка. Это именно таблица символов. То, как символы с соответствующими кодами будут храниться в памяти компьютера, зависит от конкретной кодировки, базирующейся на Юникоде,  например UTF-8. Про отличие таблицы символов Unicode от кодировки UTF-8 можно почитать тут.
Примечание 3. Первые 128 кодов таблицы символов Unicode совпадают с ASCII.
Функция ord
Функция ord позволяет определить код некоторого символа в таблице символов Unicode. Аргументом данной функции является одиночный символ.
Результатом выполнения следующего кода:
num1 = ord('A')
num2 = ord('B')
num3 = ord('a') 
print(num1, num2, num3)
будет:
65 66 97
Обратите внимание, что функция ord принимает именно одиночный символ. Если попытаться передать строку, содержащую более одного символа:
num = ord('Abc')
print(num)
мы получим ошибку времени выполнения:
TypeError: ord() expected a character, but string of length 3 found
Функция chr
Функция chr позволяет определить по коду символа сам символ. Аргументом данной функции является численный код.
Результатом выполнения следующего кода:
chr1 = chr(65)
chr2 = chr(75)
chr3 = chr(110) 
print(chr1, chr2, chr3)
будет:
A K n
Функции ord и chr часто работают в паре. Мы можем использовать следующий код для вывода всех заглавных букв английского алфавита:
for i in range(26):
    print(chr(ord('A') + i))
Вызов функции ord('A') возвращает код символа «A», который равен 65. Далее на каждой итерации цикла, к данному коду прибавляется значение переменной i = 0, 1, 2, ..., 25, а затем полученный код преобразуется в символ с помощью вызова функции chr.

Примечание. Функции ord и chr являются взаимнообратными. Для них выполнены равенства:
chr(ord('A')) = 'A', ord(chr(65)) = 65.

14.11.2022.
Списки
В предыдущих уроках мы работали с последовательностями чисел, символов, строк, но не сохраняли всю последовательность в памяти компьютера, а обрабатывали ее поэлементно, считывая раз за разом новый элемент. Однако во многих задачах требуется сохранять всю последовательность. Например, классическая задача сортировки (упорядочения) некоторой последовательности требует сохранения всех данных в памяти компьютера. Увы, не сохранив, их невозможно отсортировать. И тут на помощь приходит структура данных, которая в большинстве языков программирования называется массивом. В Python она называется списком.
Структура данных (data structure) — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.
Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.
Создание списка
Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']

Список numbers состоит из 5 элементов, и каждый из них — целое число.
numbers[0] == 2;
numbers[1] == 4;
numbers[2] == 6;
numbers[3] == 8;
numbers[4] == 10.

Список languages состоит из 4 элементов, каждый из которых — строка.
languages[0] == 'Python';
languages[1] == 'C#';
languages[2] == 'C++';
languages[3] == 'Java'.
Значения, заключенные в квадратные скобки и отделенные запятыми, называются элементами списка.
Список может содержать значения разных типов данных:
info = ['Timur', 1992, 61.5]
Список info содержит строковое значение, целое число и число с плавающей точкой.
info[0] == 'Timur';
info[1] == 1992;
info[2] == 61.5.
Обычно элементы списка содержат данные одного типа и на практике редко приходится создавать списки содержащие элементы разных типов данных.

Пустой список
Создать пустой список можно двумя способами:
Использовать пустые квадратные скобки [];
Использовать встроенную функцию, которая называется list.
Следующие две строки кода создают пустой список:
mylist = []       # пустой список
mylist = list()   # пустой список

Вывод списка
Для вывода всего списка можно применить функцию print():
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
print(numbers)
print(languages)
Функция print() выводит на экран элементы списка, в квадратных скобках, разделенные запятыми:
[2, 4, 6, 8, 10]
['Python', 'C#', 'C++', 'Java']
Встроенная функция list
Python имеет встроенную функцию list(), которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки.
Например, мы знаем, что функция range() создает последовательность целых чисел в заданном диапазоне. Для преобразования этой последовательности в список, мы пишем следующий код:
numbers = list(range(5))
Во время исполнения этого кода происходит следующее:
Вызывается функция range(), в которую в качестве аргумента передается число 5;
Эта функция возвращает последовательность чисел 0, 1, 2, 3, 4;
Последовательность чисел 0, 1, 2, 3, 4 передается в качестве аргумента в функцию list();
Функция list() возвращает список [0, 1, 2, 3, 4];
Список [0, 1, 2, 3, 4] присваивается переменной numbers.
Вот еще один пример:
even_numbers = list(range(0, 10, 2))  # список содержит четные числа 0, 2, 4, 6, 8
odd_numbers = list(range(1, 10, 2))   # список содержит нечетные числа 1, 3, 5, 7, 9
Точно также с помощью функции list() мы можем создать список из символов строки.  Для преобразования строки в список мы пишем следующий код:
s = 'abcde'
chars = list(s)  # список содержит символы 'a', 'b', 'c', 'd', 'e'
Во время исполнения этого кода происходит следующее:
Вызывается функция list(), в которую в качестве аргумента передается строка 'abcde';
Функция list() возвращает список ['a', 'b', 'c', 'd', 'e'];
Список ['a', 'b', 'c', 'd', 'e'] присваивается переменной chars.
Примечание 1. Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.
Примечание 2. Обратите внимание, при выводе содержимого списка с помощью функции print(), все строковые элементы списка обрамляются одинарными кавычками. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.

14.11.2022
Списки
В предыдущих уроках мы работали с последовательностями чисел, символов, строк, но не сохраняли всю последовательность в памяти компьютера, а обрабатывали ее поэлементно, считывая раз за разом новый элемент. Однако во многих задачах требуется сохранять всю последовательность. Например, классическая задача сортировки (упорядочения) некоторой последовательности требует сохранения всех данных в памяти компьютера. Увы, не сохранив, их невозможно отсортировать. И тут на помощь приходит структура данных, которая в большинстве языков программирования называется массивом. В Python она называется списком.
Структура данных (data structure) — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных.
Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.
Создание списка
Чтобы создать список, нужно перечислить его элементы через запятую в квадратных скобках:
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']

Список numbers состоит из 5 элементов, и каждый из них — целое число.
numbers[0] == 2;
numbers[1] == 4;
numbers[2] == 6;
numbers[3] == 8;
numbers[4] == 10.

Список languages состоит из 4 элементов, каждый из которых — строка.
languages[0] == 'Python';
languages[1] == 'C#';
languages[2] == 'C++';
languages[3] == 'Java'.
Значения, заключенные в квадратные скобки и отделенные запятыми, называются элементами списка.
Список может содержать значения разных типов данных:
info = ['Timur', 1992, 61.5]
Список info содержит строковое значение, целое число и число с плавающей точкой.
info[0] == 'Timur';
info[1] == 1992;
info[2] == 61.5.
Обычно элементы списка содержат данные одного типа и на практике редко приходится создавать списки содержащие элементы разных типов данных.
Пустой список
Создать пустой список можно двумя способами:
Использовать пустые квадратные скобки [];
Использовать встроенную функцию, которая называется list.
Следующие две строки кода создают пустой список:
mylist = []       # пустой список
mylist = list()   # пустой список

Вывод списка
Для вывода всего списка можно применить функцию print():
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']
print(numbers)
print(languages)
Функция print() выводит на экран элементы списка, в квадратных скобках, разделенные запятыми:
[2, 4, 6, 8, 10]
['Python', 'C#', 'C++', 'Java']
Встроенная функция list
Python имеет встроенную функцию list(), которая помимо создания пустого списка может преобразовывать некоторые типы объектов в списки.
Например, мы знаем, что функция range() создает последовательность целых чисел в заданном диапазоне. Для преобразования этой последовательности в список, мы пишем следующий код:
numbers = list(range(5))
Во время исполнения этого кода происходит следующее:
Вызывается функция range(), в которую в качестве аргумента передается число 5;
Эта функция возвращает последовательность чисел 0, 1, 2, 3, 4;
Последовательность чисел 0, 1, 2, 3, 4 передается в качестве аргумента в функцию list();
Функция list() возвращает список [0, 1, 2, 3, 4];
Список [0, 1, 2, 3, 4] присваивается переменной numbers.
Вот еще один пример:
even_numbers = list(range(0, 10, 2))  # список содержит четные числа 0, 2, 4, 6, 8
odd_numbers = list(range(1, 10, 2))   # список содержит нечетные числа 1, 3, 5, 7, 9
Точно также с помощью функции list() мы можем создать список из символов строки.  Для преобразования строки в список мы пишем следующий код:
s = 'abcde'
chars = list(s)  # список содержит символы 'a', 'b', 'c', 'd', 'e'
Во время исполнения этого кода происходит следующее:
Вызывается функция list(), в которую в качестве аргумента передается строка 'abcde';
Функция list() возвращает список ['a', 'b', 'c', 'd', 'e'];
Список ['a', 'b', 'c', 'd', 'e'] присваивается переменной chars.
Примечание 1. Как уже было сказано, списки в Python аналогичны массивам в других языках программирования. Однако разница между списками и массивами все же существует. Элементы массива всегда имеют одинаковый тип данных и располагаются в памяти компьютера непрерывным блоком, а элементы списка могут быть разбросаны по памяти как угодно и могут иметь разный тип данных.
Примечание 2. Обратите внимание, при выводе содержимого списка с помощью функции print(), все строковые элементы списка обрамляются одинарными кавычками. Если требуется осуществить вывод в двойных кавычках, нужно самостоятельно писать код вывода.
Основы работы со списками
Работа со списками очень сильно напоминает работу со строками, поскольку и списки, и строки содержат отдельные элементы: элементы списка могут иметь произвольный тип, а элементами строк всегда являются символы. Многое из того, что мы делали со строками, доступно и при работе со списками.
Функция len()
Длиной списка называется количество его элементов. Для того, чтобы посчитать длину списка мы используем встроенную функцию len() (от слова length – длина).
Следующий программный код:
numbers = [2, 4, 6, 8, 10]
languages = ['Python', 'C#', 'C++', 'Java']

print(len(numbers))      # выводим длину списка numbers
print(len(languages))    # выводим длину списка languages

print(len(['apple', 'banana', 'cherry']))   # выводим длину списка, состоящего из 3 элементов
выведет:
5
4
3

Оператор принадлежности in
Оператор in позволяет проверить, содержит ли список некоторый элемент.
Рассмотрим следующий код:
numbers = [2, 4, 6, 8, 10]
if 2 in numbers:
    print('Список numbers содержит число 2')
else:
    print('Список numbers не содержит число 2')
Такой код проверяет, содержит ли список numbers число 2 и выводит соответствующий текст:
Список numbers содержит число 2
Мы можем использовать оператор in вместе с логическим оператором not. Например
numbers = [2, 4, 6, 8, 10]
if 0 not in numbers:
    print('Список numbers не содержит нулей')
Индексация
При работе со строками мы использовали индексацию, то есть обращение к конкретному символу строки по его индексу. Аналогично, можно индексировать и списки.
Для индексации списков в Python используются квадратные скобки [], в которых указывается индекс (номер) нужного элемента в списке:
Пусть numbers = [2, 4, 6, 8, 10].
Таблица ниже, показывает как работает индексация:
![image](https://user-images.githubusercontent.com/112687983/201611277-f3f5da55-9f77-4501-bf19-78604c647dad.png)
![image](https://user-images.githubusercontent.com/112687983/201611753-878c53d1-b46c-401a-af2b-81eaf083384a.png)
![image](https://user-images.githubusercontent.com/112687983/201611825-6f55715e-a3ae-46ae-a006-83344095c4d9.png)
Срезы
Рассмотрим список numbers = [2, 4, 6, 8, 10].
С помощью среза мы можем получить несколько элементов списка, создав диапазон индексов разделенных двоеточием numbers[x:y].
Следующий программный код:
print(numbers[1:3])
print(numbers[2:5])
выводит:
[4, 6]
[6, 8, 10]
При построении среза numbers[x:y] первое число – это то место, где начинается срез (включительно), а второе – это место, где заканчивается срез (невключительно). Разрезая списки, мы создаем новые списки, по сути, подсписки исходного.
При использовании срезов со списками мы также можем опускать второй параметр в срезе numbers[x:] (но поставить двоеточие), тогда срез берется до конца списка. Аналогично если опустить первый параметр numbers[:y], то можно взять срез от начала списка.
Срез numbers[:] возвращает копию исходного списка.
Как и в строках, мы можем использовать отрицательные индексы в срезах списков.
Использование срезов для изменения элементов в заданном диапазоне
Для изменения целого диапазона элементов списка можно использовать срезы. Например, если мы хотим перевести на русский язык названия фруктов 'banana', 'cherry', 'kiwi', то это можно сделать с помощью среза.
Следующий программный код:
fruits = ['apple', 'apricot', 'banana', 'cherry', 'kiwi', 'lemon', 'mango']
fruits[2:5] = ['банан', 'вишня', 'киви']
print(fruits)
выводит:
['apple', 'apricot', 'банан', 'вишня', 'киви', 'lemon', 'mango']
Операция конкатенации + и умножения на число *
Мы можем применять операторы + и * для списков подобно тому как мы это делали со строками.
Следующий программный код:
print([1, 2, 3, 4] + [5, 6, 7, 8])
print([7, 8] * 3)
print([0] * 10)
выводит:
[1, 2, 3, 4, 5, 6, 7, 8]
[7, 8, 7, 8, 7, 8]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Для генерации списков, состоящих строго из повторяющихся элементов, умножение на число — самый короткий и правильный метод.
Мы также можем использовать расширенные операторы += и *= при работе со списками.
Следующий программный код:
a = [1, 2, 3, 4]
b = [7, 8]
a += b   # добавляем к списку a список b
b *= 5   # повторяем список b 5 раз 
print(a)
print(b)

выводит:
[1, 2, 3, 4, 7, 8]
[7, 8, 7, 8, 7, 8, 7, 8, 7, 8]
Встроенные функции sum(), min(), max()

Встроенная функция sum() принимает в качестве параметра список чисел и вычисляет сумму его элементов.
Следующий программный код:
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print('Сумма всех элементов списка =', sum(numbers))
выводит:
Сумма всех элементов списка = 55
Встроенные функции min() и max() принимают в качестве параметра список и находят минимальный и максимальный элементы соответственно.
Следующий программный код:
numbers = [3, 4, 10, 3333, 12, -7, -5, 4]
print('Минимальный элемент =', min(numbers))
print('Максимальный элемент =', max(numbers))
выводит:
Минимальный элемент = -7
Максимальный элемент = 3333
Отличие списков от строк
Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.
 Следующий программный код:
s = 'abcdefg'
s[1] = 'x'    # пытаемся изменить 2 символ (по индексу 1) строки
приводит к ошибке:
object does not support item assignment

Следующий программный код:
numbers = [1, 2, 3, 4, 5, 6, 7]
numbers[1] = 101     # изменяем 2 элемент (по индексу 1) списка
print(numbers)
выводит:
[1, 101, 3, 4, 5, 6, 7]
ВАЖНО: изменять отдельные символы строк нельзя, однако можно изменять отдельные элементы списков. Для этого используем индексатор и оператор присваивания.

21.11.2022
Регулярные выражения в Python
Что такое регулярное выражение? Для чего используется Regular Expressions в Python?

Регулярное выражение (Regular Expression, RegEx) — это мощный, гибкий и эффективный инструмент для сопоставления текста на основе заранее определенного шаблона. Т.е. регулярные выражения позволяют найти строки или наборы строк в тексте, используя специализированный синтаксис, с помощью которого описывается шаблон для поиска. Универсальные шаблоны регулярных выражений напоминают миниатюрный язык программирования, который предназначен для описания и разбора текста.

Регулярное выражение — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных строчек. Термин «Регулярные выражения» является переводом английского словосочетания «Regular expressions». Перевод не очень точно отражает смысл, правильнее было бы «шаблонные выражения». Регулярное выражение, или коротко «регулярка», состоит из обычных символов и специальных командных последовательностей.
 Например, \d задаёт любую цифру, а \d+ — задает любую последовательность из одной или более цифр. 

Примеры регулярных выражений
import re

#Проверка на почту
list = ["taвсыrdv69@yanввdex.ru", "tardv69@yandex.ru", "t@yandex.ru"]
for test in list:
  x = re.search("[a-zA-Z0-9]@[a-zA-Z0-9]+\.ru", test)
  if x:
    print("YES! We have email!", test)
  else:
    print("No email", test)

#Проверка на телефон
import re

phones=['+79159171517','+79108051624','+89102626450']
for phone in phones:
  x=re.search('^\\+?[7][0-9]{10}$',phone)
  if x:
    print('YES! We have phone')
  else:
    print('No phone')
Давайте попробуем понять, почему нам следует использовать регулярные выражения для работы с текстом?
Вот несколько сценариев для работы с RegEx в Python:
Data Mining: регулярное выражение — лучший инструмент для интеллектуального анализа данных. Он эффективно идентифицирует текст (строку, подстроку) в большом объеме текста, проверяя его по заранее заданному шаблону. Некоторые распространенные сценарии — определение адреса электронной почты, URL-адреса или телефона из большого объема текста.
Data Validation (Проверка данных): регулярное выражение подходит также для таких задач, как проверка данных. Он может включать в себя широкий спектр процессов проверки путем определения различных наборов шаблонов. Вот несколько примеров: проверка номеров телефонов, электронной почты и т.д.

Модуль Re (import re) — операции с регулярными выражениями
Python имеет встроенный пакет с именем re, который можно использовать для работы с регулярными выражениями.
Этот модуль предоставляет операции сопоставления регулярных выражений в Python, аналогичные тем, которые имеются в Perl. Основная функция модуля re — предложить поиск, в котором используются регулярное выражение и строка. Здесь он либо возвращает первое совпадение, либо ничего. Модуль re вызывает исключение re.error, если ошибка возникает при компиляции или использовании регулярного выражения.
Команда для импорта модуля re:
import re

Краткое описание синтаксиса RegEx на примере с Email
Для того, чтобы кратко познакомиться с Regular Expression, рассмотрим два примера и описание некоторых компонентов регулярного выражения.
Пример регулярного выражения для проверки email с пометкой каждого компонента:

Регулярные выражения в Python (regex find match groups replace string)

ПАРСИНГ ТЕКСТА В PYTHON. РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
Регулярные выражения в Python (regex find match groups replace string)
Шамаев Иван
Posted by
Шамаев Иван

Содержание страницы
Что такое регулярное выражение? Для чего используется Regular Expressions в Python?
Почему регулярные выражения?
Модуль Re (import re) — операции с регулярными выражениями
Краткое описание синтаксиса RegEx на примере с Email
Работа с модулем Re. Import re
RegEx в Python
Вводный пример RegEx на Python
Функции RegEx
Metacharacters (Метасимволы)
Special Sequences RegEx (Специальные последовательности)
Sets (Наборы)
Символ \ — бэкслеш в Python RegEx
Проверка и тестирование регулярных выражений
Функция findall()
Функция search()
Функция split()
Функция sub()
Функция subn()
Функция match()
Функция fullmatch()
Функция compile()
Функция finditer()
Match Object
Flags (флаги)
Примеры решения задач с помощью модуля Re
Подборка видео по теме «Regular Expressions в Python»
Не бойтесь регулярных выражений. Regex за 20 минут!
Python для Начинающих — Регулярные Выражения
Python с нуля. Регулярные выражения
Python 3. Регулярные выражения — плейлист
TelegramWhatsAppFacebookLinkedInVKTwitterEmailРесурс
Что такое регулярное выражение? Для чего используется Regular Expressions в Python?
Регулярное выражение (Regular Expression, RegEx) — это мощный, гибкий и эффективный инструмент для сопоставления текста на основе заранее определенного шаблона. Т.е. регулярные выражения позволяют найти строки или наборы строк в тексте, используя специализированный синтаксис, с помощью которого описывается шаблон для поиска. Универсальные шаблоны регулярных выражений напоминают миниатюрный язык программирования, который предназначен для описания и разбора текста.

Почему регулярные выражения?
Давайте попробуем понять, почему нам следует использовать регулярные выражения для работы с текстом?

Вот несколько сценариев для работы с RegEx в Python:

Data Mining: регулярное выражение — лучший инструмент для интеллектуального анализа данных. Он эффективно идентифицирует текст (строку, подстроку) в куче текста, проверяя его по заранее заданному шаблону. Некоторые распространенные сценарии — определение адреса электронной почты, URL-адреса или телефона из кучи текста.
Data Validation (Проверка данных): регулярное выражение может идеально подойти для таких задач, как проверка данных. Он может включать в себя широкий спектр процессов проверки путем определения различных наборов шаблонов. Вот несколько примеров: проверка номеров телефонов, электронной почты и т.д.
Модуль Re (import re) — операции с регулярными выражениями
Python имеет встроенный пакет с именем re, который можно использовать для работы с регулярными выражениями.

Этот модуль предоставляет операции сопоставления регулярных выражений в Python, аналогичные тем, которые имеются в Perl. Основная функция модуля re — предложить поиск, в котором используются регулярное выражение и строка. Здесь он либо возвращает первое совпадение, либо ничего. Модуль re вызывает исключение re.error, если ошибка возникает при компиляции или использовании регулярного выражения.

Команда для импорта модуля re:

import re
Краткое описание синтаксиса RegEx на примере с Email
Для того, чтобы кратко познакомиться с Regular Expression, рассмотрим два примера и описание некоторых компонентов регулярного выражения.

Пример регулярного выражения для проверки email с пометкой каждого компонента:



Еще один пример с почтой:



Описание некоторых общих компонентов регулярных выражений:

Символ + в регулярном выражении означает «сопоставить предыдущий символ один или несколько раз». Например, ab+c соответствует «abc», «abbc», «abbbc», но не соответствует «ac» . Знак плюс, используемый в регулярном выражении, называется Клини плюс в честь математика Стивена Клини (1909–1994), который ввел эту концепцию.
Символ * в регулярном выражении означает «сопоставить предыдущий символ ноль или более раз». Например, ab*c соответствует «abc», «abbc», «abbbc» и «ac». Это называется звездой Клини.
Знак вопроса ? указывает на 0 или 1 вхождение предыдущего элемента. Например, colou?r соответствует как «color», так и «colour».
Точка соответствует любому одиночному символу (кроме символа новой строки). Например, a.c соответствует «abc», «adc», «aec» и т.д. Если мы хотим сопоставить несколько символов перед буквой «c», мы бы просто использовали звездочку * следующим образом: a.*c и это будет соответствовать «a bdefgh c».
[a-z]: очень полезно, так как определяет диапазон возможных значений — относится ко всем строчным буквам алфавита от a до z. Мы можем сделать то же самое для букв верхнего регистра и всех положительных чисел, подобных этому [A-Z] & [0-9].
^: Соответствует начальной позиции любой строки.
[^b]at соответствует всем строкам, за .at исключением «bat». Поэтому при использовании ^ в квадратных скобках следующая буква исключается.
^[hc]at соответствует  «hat» и «cat», но только в начале строки.
\ Backspace экранирует точку, поэтому наше регулярное выражение не считает, что это часть наших квантификаторов, как определено выше. Нам нужно, чтобы точка была буквально частью нашего шаблона, поскольку она находится в нашем поисковом шаблоне.
Работа с модулем Re. Import re
RegEx в Python
Регулярные выражения — это, по сути, крошечный узкоспециализированный язык программирования, встроенный в Python и доступный через модуль re.

Используя этот небольшой язык, вы указываете правила для набора возможных строк, которые вы хотите сопоставить:

этот набор может содержать английские предложения,
или адреса электронной почты,
или команды TeX,
и т.д.
Затем вам необходимо задать такие вопросы, как «Соответствует ли эта строка шаблону?» или «Есть ли где-нибудь в этой строке совпадение с шаблоном?».

Модель RE также можно использовать для изменения строки или разделения ее на части различными способами.

Шаблоны регулярных выражений компилируются в серию байт-кодов, которые затем выполняются механизмом сопоставления, написанным на C определенным образом для создания байт-кода, который работает быстрее.

Язык регулярных выражений относительно мал и ограничен, поэтому не все возможные задачи обработки строк можно выполнить с помощью регулярных выражений. Есть также задачи, которые можно решить с помощью регулярных выражений, но выражения получаются очень сложными. В этих случаях вам может быть лучше написать код Python для обработки; в то время как код Python будет медленнее, чем сложное регулярное выражение, он также, вероятно, будет более понятным.

Вводный пример RegEx на Python
Когда вы импортировали re модуль, вы можете начать использовать регулярные выражения:

Пример — Проверим строку, что она начинается с ‘The’ и заканчивается ‘Spain’:

import re
#Check if the string starts with "The" and ends with "Spain":
txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)
if x:
  print("YES! We have a match!")
else:
  print("No match")
Результат:

YES! We have a match!
Функции RegEx
Регулярные выражения компилируются в объекты шаблонов, которые имеют методы для различных операций, таких как поиск совпадений с шаблоном или выполнение подстановки строк.

Модуль re предоставляет набор функций/методов, которые позволяют нам искать строку по совпадению:

findall() — Возвращает список, содержащий все совпадения
search() — Возвращает объект Match, если где-либо в строке есть совпадение
split() — Возвращает список, в котором строка была разделена при каждом совпадении
sub() — Заменяет одно или несколько совпадений строкой
subn() — Делает то же самое, что и sub(), но возвращает новую строку и количество замен
match() — Ищет совпадение с начала строки
finditer() — Ищет все совпадения с pattern, возвращает итератор
compile() — Компилирует regular expression, на выходе получаем объект, к которому затем можно применять все перечисленные функции
fullmatch() — Проверяет, что вся строка соответствует описанному регулярному выражению
flags (флаги) — Указываются в функциях, влияют на поведение регулярного выражения
Metacharacters (Метасимволы)
Метасимволы — это символы со специальным значением:

Meta Character	Описание
[…]	Набор символов
[^…]	Отрицательный класс символов. Соответствует любому символу, не заключенному в квадратные скобки
\	Сообщает о специальной последовательности (также может использоваться для экранирования специальных символов)
.	Любой символ (кроме символа новой строки)
^	Начинается с
$	Заканчивается на
*	Ноль или более случаев
+	Одно или несколько случаев
?	Ноль или одно вхождение
{}	Ровно указанное количество вхождений
{n,m}	Соответствует не менее «n», но не более «m» повторений предыдущего символа.
|	Чередование. Соответствует символам до или после символа |
()	Захват и группировка
(xyz)	Группа символов. Соответствует символам xyz именно в этом порядке.
Special Sequences RegEx (Специальные последовательности)
Специальная последовательность — это когда за символом \ следует один из символов в списке ниже, которая имеет особое значение:

Character	Описание
\A	Возвращает совпадение, если указанные символы находятся в начале строки
\b	Возвращает совпадение, в котором указанные символы находятся в начале или в конце слова
\B	Возвращает совпадение, в котором указанные символы присутствуют, но НЕ в начале (или в конце) слова
\d	Возвращает совпадение, в котором строка содержит цифры (числа от 0 до 9)
\D	Возвращает совпадение, в котором строка НЕ ​​содержит цифр
\s	Возвращает совпадение, в котором строка содержит символ пробела
\S	Возвращает совпадение, в котором строка НЕ ​​содержит пробела
\w	Возвращает совпадение, в котором строка содержит любые символы слова (символы от a до Z, цифры от 0 до 9 и символ подчеркивания _ )
\W	Возвращает совпадение, в котором строка НЕ ​​содержит символов слова
\Z	Возвращает совпадение, если указанные символы находятся в конце строки
Sets (Наборы)
Set (Набор) — это набор символов внутри пары квадратных скобок [] со специальным значением:

Set	Описание
[arn]	Возвращает совпадение, в котором присутствует один из указанных символов (a, r или n)
[a-n]	Возвращает совпадение для любого символа нижнего регистра в алфавитном порядке от a до n
[^arn]	Возвращает совпадение для любого символа, ЗА ИСКЛЮЧЕНИЕМ a, r и n
[0123]	Возвращает совпадение, в котором присутствует любая из указанных цифр (0, 1, 2 или 3)
[0-9]	Возвращает совпадение для любой цифры от 0 до 9
[0-5][0-9]	Возвращает совпадение для любых двузначных чисел от 00 до 59
[a-zA-Z]	Возвращает соответствие для любого символа в алфавитном порядке от a до z, в нижнем регистре ИЛИ в верхнем регистре
[+]	В наборах + * . | () $ {} знак не имеет особого значения, поэтому [+] означает: вернуть совпадение для любого символа + в строке
Символ \ — бэкслеш в Python RegEx
Регулярные выражения используют символ обратной косой черты (‘\’) для обозначения специальных форм или для разрешения использования специальных символов без обращения к их особому значению. Это противоречит тому, что Python использует тот же символ для той же цели в строковых литералах.

Допустим, вы хотите написать RE, который соответствует строке \section, которая может быть найдена в файле. Чтобы понять, что писать в программном коде, начните с нужной строки для сопоставления. Затем вы должны экранировать обратную косую черту и другие метасимволы, предваряя их обратной косой чертой, в результате чего получится строка \\section.

Результирующая строка, которую необходимо передать, re.compile() должна быть \\section. Однако, чтобы выразить это как строковый литерал Python, обе обратные косые черты должны быть снова экранированы.

Символы	Этап
\section	Текстовая строка для сопоставления
\\section	Экранированная обратная косая черта для re.compile()
"\\\\section"	Экранированные символы обратной косой черты для строкового литерала
Решение состоит в том, чтобы использовать для регулярных выражений нотацию необработанных строк Python. Обратная косая черта не обрабатывается каким-либо особым образом в строковом литерале с префиксом ‘r’:

r"\\section"
Регулярные выражения часто записываются в коде Python с использованием этой записи необработанных строк:

Regular String	Raw string
"ab*"	r"ab*"
"\\\\section"	r"\\section"
"\\w+\\s+\\1"	r"\w+\s+\1"
Проверка и тестирование регулярных выражений
https://regex101.com/ — интерактивная консоль регулярных выражений, которая позволяет отлаживать выражения в режиме реального времени. Это означает, что вы можете создавать свои выражения и одновременно видеть, как они влияют на набор данных в реальном времени на одном экране. Инструмент был создан Фирасом Дибом при участии многих других разработчиков. Это крупнейший сервис тестирования регулярных выражений в мире.
http://www.pyregex.com/ — онлайн-тестер регулярных выражений для проверки правильности регулярных выражений в подмножестве регулярных выражений языка Python.
https://pythex.org/ — Pythex is a real-time regular expression editor for Python, a quick way to test your regular expressions.
Функция findall()
Определение функции

Функция findall() возвращает список, содержащий все совпадения.

Модуль findall() используется для поиска «всех» вхождений, соответствующих заданному шаблону. Напротив, модуль search() вернет только первое вхождение, соответствующее указанному шаблону. findall() перебирает все строки файла и возвращает все непересекающиеся совпадения шаблона за один шаг.

Синтаксис

re.findall(pattern, string, flags=0)
Пример использования

Функция search()
Определение функции

Функция search() будет искать шаблон регулярного выражения и возвращать первое вхождение. В отличие от Python match(), он проверяет все строки входной строки. Функция Python search() возвращает объект соответствия, когда шаблон найден, и «ноль», если шаблон не найден.

Синтаксис

re.search(pattern, string, flags=0)
Пример использования

туду

Функция split()
Определение функции

Функция split() работает аналогично методу split в строках, но в функции re.split можно использовать регулярные выражения, а значит, разделять строку на части по более сложным условиям.

Синтаксис

re.split(pattern, string, maxsplit=0, flags=0)
Пример использования

туду

Функция sub()
Определение функции

Функция re.sub работает аналогично методу replace в строках. Но в функции re.sub можно использовать регулярные выражения, а значит, делать замены по более сложным условиям.

Синтаксис

re.sub(pattern, repl, string, count=0, flags=0)
Пример использования

туду

Функция subn()
Определение функции

Функция subn() аналогична sub(), но возвращает новую строку и количество произведенных замен.

Синтаксис

re.subn(pattern, repl, string, count=0, flags=0)
Пример использования

туду

Функция match()
Определение функции

Функция re.match() re в Python будет искать шаблон регулярного выражения только в начале строки. Функция match() возвращает объект соответствия, если часть начала строки подпадает под шаблон, иначе функция вернет None.

Синтаксис

re.match(pattern, string, flags=0)
Пример использования

туду

Функция fullmatch()
Определение функции

Функция re.fullmatch() вернет объект сопоставления, если вся исходная строка соответствует шаблону Regular Expression.

Синтаксис

re.fullmatch(pattern, string, flags=0)
Пример использования

туду

Функция compile()
Определение функции

В Python есть возможность заранее скомпилировать регулярное выражение, а затем использовать его. Это особенно полезно в тех случаях, когда регулярное выражение много используется в скрипте.

Использование компилированного выражения может ускорить обработку, и, как правило, такой вариант удобней использовать, так как в программе разделяется создание регулярного выражения и его использование. Кроме того, при использовании функции re.compile создается объект RegexObject, у которого есть несколько дополнительных возможностей, которых нет в объекте MatchObject.

Синтаксис

re.compile(pattern, flags=0)
Пример использования

туду

Функция finditer()
Определение функции

Метод finditer() используется для поиска всех непересекающихся совпадений в шаблоне и возвращает итератор с объектами Match (finditer возвращает итератор даже в том случае, когда совпадение не найдено). Функция finditer отлично подходит для обработки тех команд, вывод которых отображается столбцами.

Синтаксис

re.finditer(pattern, string, flags=0)
Пример использования

туду

Match Object
Определение

Match Object — это объект, содержащий информацию о поиске и результате.

Объект Match имеет свойства и методы, используемые для получения информации о поиске и результате:

.span() возвращает кортеж, содержащий начальную и конечную позиции совпадения.
.string возвращает строку, переданную в функцию,
.group() возвращает часть строки, в которой произошло совпадение
Flags (флаги)
